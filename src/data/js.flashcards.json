[
  {
    "question": "What are the different types present in JavaScript?",
    "answer": "In JavaScript, there are primitive types, which include: string, number, bigint, boolean, symbol, null, and undefined. Non-primitive (reference) types include objects, arrays, and functions."
  },
  {
    "question": "Explain hoisting in JavaScript.",
    "answer": "Hoisting in JavaScript means that variable and function declarations are moved to the top of their scope during compilation. Function declarations are fully hoisted, meaning both their name and definition are available before execution, while variables declared with var are initialized as undefined. let and const are hoisted but remain uninitialized in the Temporal Dead Zone."
  },
  {
    "question": "What is the difference between var, let, and const?",
    "answer": "var is function-scoped and can be redeclared, while let and const are block-scoped. const variables cannot be reassigned, while let allows reassignment. var variables are hoisted and initialized as undefined, whereas let and const are hoisted but not initialized."
  },
  {
    "question": "What is pass-by-value and pass-by-reference?",
    "answer": "In JavaScript, primitive types are passed by value, meaning a copy of the value is passed. Non-primitive types like objects and arrays are passed by reference, meaning the reference to the memory location is passed, so changes affect the original."
  },
  {
    "question": "What is the difference between a deep copy and a shallow copy?",
    "answer": "A shallow copy copies only the top-level properties of an object or array, while a deep copy creates an independent copy of all levels, including nested objects and arrays. Methods like spread (...) and Object.assign() create shallow copies, while JSON.parse(JSON.stringify()) or libraries like lodash.cloneDeep() create deep copies."
  },
  {
    "question": "What are self-invoking functions or Immediately Invoked Function Expressions (IIFEs)?",
    "answer": "Self-invoking functions, or IIFEs, are functions that are executed immediately after they are defined. They are useful for creating private scopes and avoiding polluting the global namespace. Syntax: (function() { /* code */ })();"
  },
  {
    "question": "What is strict mode in JavaScript?",
    "answer": "Strict mode is a way to enforce stricter parsing and error handling in JavaScript by adding 'use strict' at the beginning of a file or function. It prevents common mistakes like using undeclared variables and makes the code more secure."
  },
  {
    "question": "Explain higher-order functions in JavaScript.",
    "answer": "Higher-order functions are functions that take other functions as arguments or return functions as their result. Examples include array methods like map, filter, and reduce, which allow for concise and reusable code."
  },
  {
    "question": "What is the this keyword in JavaScript?",
    "answer": "The this keyword refers to the execution context of a function. In global functions, it points to the global object in non-strict mode and undefined in strict mode. In object methods, it refers to the object calling the method. Arrow functions inherit this from their enclosing scope."
  },
  {
    "question": "What are call(), apply(), and bind() methods in JavaScript?",
    "answer": "call() invokes a function with a specified this and arguments passed individually. apply() works like call() but takes arguments as an array. bind() creates a new function with a specified this and optional initial arguments, which can be called later."
  },
  {
    "question": "What is currying in JavaScript?",
    "answer": "Currying is a technique where a function with multiple arguments is transformed into a sequence of functions, each taking a single argument (or a subset of arguments)."
  },
  {
    "question": "What is lexical scoping in JavaScript?",
    "answer": "Lexical scoping in JavaScript means that the scope of a variable is determined by its location in the source code. Nested functions have access to variables declared in their parent scope."
  },
  {
    "question": "What are closures in JavaScript?",
    "answer": "Closures occur when an inner function remembers and can access variables from its outer function's scope, even after the outer function has finished executing."
  },
  {
    "question": "What is implicit coercion in JavaScript?",
    "answer": "Implicit coercion is the automatic conversion of a value from one type to another (e.g., string to number) during operations or comparisons, such as '5' + 1 resulting in '51'."
  },
  {
    "question": "What does it mean for functions to be 'first-class citizens' in JavaScript?",
    "answer": "Functions are first-class citizens in JavaScript because they can be assigned to variables, passed as arguments, returned from functions, and stored in data structures."
  },
  {
    "question": "What is the significance of the new keyword in JavaScript?",
    "answer": "The new keyword in JavaScript is used to create an instance of an object that is based on a constructor function or class. It initializes the object, sets up its prototype chain, and binds this inside the constructor to the newly created object."
  },
  {
    "question": "What is memoization in JavaScript?",
    "answer": "Memoization is an optimization technique where the results of expensive function calls are cached based on their inputs, so the function doesn't need to recompute the result for the same inputs, improving performance."
  },
  {
    "question": "What are Map, WeakMap, and WeakSet in JavaScript?",
    "answer": "Map is a collection of key-value pairs where keys can be of any type. WeakMap only allows objects as keys and weakly holds them, enabling garbage collection. WeakSet is a collection of unique objects, also weakly held."
  },
  {
    "question": "What is event propagation in JavaScript?",
    "answer": "Event propagation in JavaScript is the mechanism that defines how events flow through the DOM tree. It has two main phases: capturing (event travels from the root to the target) and bubbling (event travels from the target back to the root)."
  },
  {
    "question": "What is event delegation in JavaScript?",
    "answer": "Event delegation is a technique in JavaScript that leverages the event propagation mechanism (specifically, the bubbling phase) to attach a single event listener to a parent element. This listener can monitor events triggered by its child elements and use event.target to determine which specific child element triggered the event."
  },
  {
    "question": "What is the event loop in JavaScript?", 
    "answer": "The event loop ensures asynchronous operations are executed by checking the call stack and queues, allowing JavaScript to handle tasks without blocking."
  },
  {
    "question": "What is control flow in JavaScript?",
    "answer": "Control flow in JavaScript refers to the order in which statements in a program are executed. It includes constructs like conditionals (if, switch), loops (for, while), and interruptions (break, return)."
  },
  {
    "question": "What is the difference between Server-Side Rendering (SSR) and Client-Side Rendering (CSR)?",
    "answer": "SSR generates HTML on the server and sends it to the client for faster initial loads and SEO, while CSR renders HTML dynamically in the browser using JavaScript for smoother interactions after loading."
  },
  {
    "question": "What is the difference between declarative and imperative programming?",
    "answer": "Declarative programming focuses on describing what the program should accomplish (e.g., React's JSX, SQL), while imperative programming focuses on how to accomplish it step-by-step (e.g., for loops)."
  },
  {
    "question": "What is debouncing and throttling in JavaScript?",
    "answer": "Debouncing delays the execution of a function until after a specified time of inactivity, while throttling ensures a function is executed at most once in a specified time interval, regardless of how often it's triggered."
  }
]
